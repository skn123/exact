#include "mutator.hxx"

GenomeOperators::GenomeOperators(
                int32_t _number_workers,
                int32_t _worker_id,
                int32_t _number_inputs,
                int32_t _number_outputs,
                int32_t _edge_innovation_count,
                int32_t _node_innovation_count,
                int32_t _min_recurrent_depth,
                int32_t _max_recurrent_depth,
                double _dropout_probability,
                DatasetMeta _datasetMeta,
                vector<string> _possible_node_type_strings) 
    : dropout_probability(_dropout_probability), dataset_meta(_dataset_meta),
      number_inputs(_number_inputs), number_outputs(_number_outputs), 
      training_parameterss(_training_parameters) {

    number_workers          = _number_workers;
    worker_id               = _worker_id;
    
    // To ensure that these are unique among workers (each worker gets a separate mutator), 
    // each worker adds its id to the count. Next, they are to be incremented by the number
    // of total workers. This ensures unique id's among workers by forcing the innovation
    // numbers for any given worker to be congruent modulo the number of workers. 
    //
    // rough proof innovation numbers are unique among threads:
    // Given: worker_id w, number of workers N, and starting count s.
    // Assuming: there are workers 0 up until N - 1
    //
    //   1. the initial edge innovation count for this mutator is s + w.
    //   2. s + w === s + w (mod N)
    //   3. assume some number k innovation numbers have been generated,
    //      incrementing the count by kN
    //   4. this number is equal to s + w + kN
    //   5. s + w + kN = s + w (mod N), implying all innovation numbers
    //      generated by worker w belong to the same congruence class
    //   6. worker ids form the set of integers 0 <= x < N, which is 
    //      the least residue system modulo N by definition
    //   7. considering (5) and (6) together implies all workers generate 
    //      innovation numbers from different congruence classes,
    //      since each worker id represents a distinct congruence class -
    //      the starting count is irrelevent here since it is added to all
    //      of the generated innovation numbers.
    //                                                                  ┌┐
    //                                                                  └┘
    
    edge_innovation_count   = _edge_innovation_count + worker_id;
    node_innovation_count   = _node_innovation_count + worker_id;

    set_possible_node_types(_possible_node_type_strings);
    
    recurrent_depth_dist = uniform_int_distribution(_min_recurrent_depth, _max_recurrent_depth);
    node_index_dist = uniform_int_distribution(0, (int) possible_node_types.size() - 1);
}

int32_t GenomeOperators::get_next_node_innovation_number() {
    return node_innovation_count++;
}

int32_t GenomeOperators::get_next_edge_innovation_number() {
    return edge_innovation_count++;
}

void GenomeOperators::set_possible_node_types(vector<string> &possible_node_type_strings) {
    if (possible_node_type_strings.size() == 0) {
        possible_node_types.push_back(SIMPLE_NODE);
        possible_node_types.push_back(JORDAN_NODE);
        possible_node_types.push_back(ELMAN_NODE);
        possible_node_types.push_back(UGRNN_NODE);
        possible_node_types.push_back(MGU_NODE);
        possible_node_types.push_back(GRU_NODE);
        possible_node_types.push_back(LSTM_NODE);
        possible_node_types.push_back(ENARC_NODE);
        possible_node_types.push_back(DELTA_NODE);
        return;
    }

    possible_node_types.clear();

    for (uint32_t i = 0; i < possible_node_type_strings.size(); i++) {
        string node_type_s = possible_node_type_strings[i];

        bool found = false;

        for (int32_t j = 0; j < NUMBER_NODE_TYPES; j++) {
            if (NODE_TYPES[j].compare(node_type_s) == 0) {
                found = true;
                possible_node_types.push_back(j);
            }
        }

        if (!found) {
            Log::error("unknown node type: '%s'\n", node_type_s.c_str());
            exit(1);
        }
    }

    if (possible_node_types.size() == 0) {
        Log::fatal("failed to specify any node types: there must be at least one node type specified");
        exit(1);
    }

}

int GenomeOperators::get_random_node_type() {
    return GenomeOperators::possible_node_types[node_index_dist(generator)];
}

void GenomeOperators::finalize_genome(RNN_Genome *g) {
    genome->set_parameter_names(datasetMeta.input_parameter_names, datasetMeta.output_parameter_names);
    genome->set_normalize_bounds(datasetMeta.normalize_type, datasetMeta.normalize_mins, datasetMeta.normalize_maxs, datasetMeta.normalize_avgs, datasetMeta.normalize_std_devs);
    genome->set_bp_iterations(training_parameters.bp_iterations);
    genome->set_learning_rate(training_parameters.learning_rate);
    genome->enable_use_regression(training_parameters.use_regression);

    if (training_parameters.use_high_threshold) genome->enable_high_threshold(training_parameters.high_threshold);
    if (training_parameters.use_low_threshold) genome->enable_low_threshold(training_parameters.low_threshold);
    if (training_parameters.use_dropout) genome->enable_dropout(training_parameters.dropout_probability);

    if (!TrainingParameters::epigenetic_weights) genome->initialize_randomly();
}

RNN_Genome *GenomeOperators::mutate(RNN_Genome *g, int32_t n_mutations) {
    bool modified = false;

    double mu, sigma;
 
    //g->write_graphviz("rnn_genome_premutate_" + to_string(g->get_generation_id()) + ".gv");
    Log::info("generating new genome by mutation.\n");

    g->get_mu_sigma(g->best_parameters, mu, sigma);
    g->clear_generated_by();
    
    // use best weights if available
    if (g->best_parameters.size() == 0) {
        g->set_weights(g->initial_parameters);
        g->get_mu_sigma(g->initial_parameters, mu, sigma);
    } else {
        g->set_weights(g->best_parameters);
        g->get_mu_sigma(g->best_parameters, mu, sigma);
    }

    int number_mutations = 0;

    for (;;) {
        if (modified) {
            modified = false;
            number_mutations++;
        }
        if (number_mutations >= n_mutations) break;

        g->assign_reachability();
        double rng = unit_dist(generator);
        int new_node_type = get_random_node_type();
        string node_type_str = NODE_TYPES[new_node_type];
        Log::debug( "rng: %lf, total: %lf, new node type: %d (%s)\n", rng, total, new_node_type, node_type_str.c_str());

        if (rng < clone_rate) {
            Log::debug("\tcloned\n");
            g->set_generated_by("clone");
            modified = true;
            continue;
        }
        rng -= clone_rate;
        if (rng < add_edge_rate) {
            modified = g->add_edge(mu, sigma, get_next_edge_innovation_number);
            Log::debug("\tadding edge, modified: %d\n", modified);
            if (modified) g->set_generated_by("add_edge");
            continue;
        }
        rng -= add_edge_rate;

        if (rng < add_recurrent_edge_rate) {
            modified = g->add_recurrent_edge(mu, sigma, recurrent_depth_dist, get_next_edge_innovation_number);
            Log::debug("\tadding recurrent edge, modified: %d\n", modified);
            if (modified) g->set_generated_by("add_recurrent_edge");
            continue;
        }
        rng -= add_recurrent_edge_rate;

        if (rng < enable_edge_rate) {
            modified = g->enable_edge();
            Log::debug("\tenabling edge, modified: %d\n", modified);
            if (modified) g->set_generated_by("enable_edge");
            continue;
        }
        rng -= enable_edge_rate;

        if (rng < disable_edge_rate) {
            modified = g->disable_edge();
            Log::debug("\tdisabling edge, modified: %d\n", modified);
            if (modified) g->set_generated_by("disable_edge");
            continue;
        }
        rng -= disable_edge_rate;

        if (rng < split_edge_rate) {
            modified = g->split_edge(mu, sigma, new_node_type, recurrent_depth_dist, get_next_edge_innovation_number, get_next_node_innovation_number);
            Log::debug("\tsplitting edge, modified: %d\n", modified);
            if (modified) g->set_generated_by("split_edge(" + node_type_str + ")");
            continue;
        }
        rng -= split_edge_rate;

        if (rng < add_node_rate) {
            modified = g->add_node(mu, sigma, new_node_type, recurrent_depth_dist, get_next_edge_innovation_number, get_next_node_innovation_number);
            Log::debug("\tadding node, modified: %d\n", modified);
            if (modified) g->set_generated_by("add_node(" + node_type_str + ")");
            continue;
        }
        rng -= add_node_rate;

        if (rng < enable_node_rate) {
            modified = g->enable_node();
            Log::debug("\tenabling node, modified: %d\n", modified);
            if (modified) g->set_generated_by("enable_node");
            continue;
        }
        rng -= enable_node_rate;

        if (rng < disable_node_rate) {
            modified = g->disable_node();
            Log::debug("\tdisabling node, modified: %d\n", modified);
            if (modified) g->set_generated_by("disable_node");
            continue;
        }
        rng -= disable_node_rate;

        if (rng < split_node_rate) {
            modified = g->split_node(mu, sigma, new_node_type, recurrent_depth_dist, get_next_edge_innovation_number, get_next_node_innovation_number);
            Log::debug("\tsplitting node, modified: %d\n", modified);
            if (modified) g->set_generated_by("split_node(" + node_type_str + ")");
            continue;
        }
        rng -= split_node_rate;

        if (rng < merge_node_rate) {
            modified = g->merge_node(mu, sigma, new_node_type, recurrent_depth_dist, get_next_edge_innovation_number, get_next_node_innovation_number);
            Log::debug("\tmerging node, modified: %d\n", modified);
            if (modified) g->set_generated_by("merge_node(" + node_type_str + ")");
            continue;
        }
        rng -= merge_node_rate;
    }
    
    //get the new set of parameters (as new paramters may have been
    //added duriung mutation) and set them to the initial parameters
    //for epigenetic_initialization

    vector<double> new_parameters;

    g->get_weights(new_parameters);
    g->initial_parameters = new_parameters;
    
    if (Log::at_level(Log::DEBUG)) {
        g->get_mu_sigma(new_parameters, mu, sigma);
    }

    g->assign_reachability();

    //reset the genomes statistics (as these carry over on copy)
    g->best_validation_mse = EXAMM_MAX_DOUBLE;
    g->best_validation_mae = EXAMM_MAX_DOUBLE;

    if (Log::at_level(Log::DEBUG)) {
        Log::debug("checking parameters after mutation\n");
        g->get_mu_sigma(g->initial_parameters, mu, sigma);
    }

    g->best_parameters.clear();
    this->finalize_genome(g);
    return g;
}

RNN_Genome *GenomeOperators::crossover(RNN_Genome *more_fit, RNN_Genome *less_fit) {
    Log::debug("generating new genome by crossover!\n");
    Log::debug("more_fit->island: %d, less_fit->island: %d\n", more_fit->get_group_id(), less_fit->get_group_id());
    Log::debug("more_fit->number_inputs: %d, less_fit->number_inputs: %d\n", more_fit->get_number_inputs(), less_fit->get_number_inputs());
    
    for (uint32_t i = 0; i < more_fit->nodes.size(); i++) {
        Log::debug("more_fit node[%d], in: %d, depth: %lf, layer_type: %d, node_type: %d, reachable: %d, enabled: %d\n", i, more_fit->nodes[i]->get_innovation_number(), more_fit->nodes[i]->get_depth(), more_fit->nodes[i]->get_layer_type(), more_fit->nodes[i]->get_node_type(), more_fit->nodes[i]->is_reachable(), more_fit->nodes[i]->is_enabled());
    }
    
    for (uint32_t i = 0; i < less_fit->nodes.size(); i++) {
        Log::debug("less_fit node[%d], in: %d, depth: %lf, layer_type: %d, node_type: %d, reachable: %d, enabled: %d\n", i, less_fit->nodes[i]->get_innovation_number(), less_fit->nodes[i]->get_depth(), less_fit->nodes[i]->get_layer_type(), less_fit->nodes[i]->get_node_type(), less_fit->nodes[i]->is_reachable(), less_fit->nodes[i]->is_enabled());
    }
    
    double _mu, _sigma;
    Log::debug("getting more_fit mu/sigma!\n");
    if (more_fit->best_parameters.size() == 0) {
        more_fit->set_weights(more_fit->initial_parameters);
        more_fit->get_mu_sigma(more_fit->initial_parameters, _mu, _sigma);
    } else {
        more_fit->set_weights(more_fit->best_parameters);
        more_fit->get_mu_sigma(more_fit->best_parameters, _mu, _sigma);
    }
    
    Log::debug("getting less_fit mu/sigma!\n");
    if (less_fit->best_parameters.size() == 0) {
        less_fit->set_weights(less_fit->initial_parameters);
        less_fit->get_mu_sigma(less_fit->initial_parameters, _mu, _sigma);
    } else {
        less_fit->set_weights(less_fit->best_parameters);
        less_fit->get_mu_sigma(less_fit->best_parameters, _mu, _sigma);
    }
    
    //nodes are copied in the attempt_node_insert_function
    vector< RNN_Node_Interface* > child_nodes;
    vector< RNN_Edge* > child_edges;
    vector< RNN_Recurrent_Edge* > child_recurrent_edges;
    
    //edges are not sorted in order of innovation number, they need to be
    vector< RNN_Edge* > more_fit_edges = more_fit->edges;
    vector< RNN_Edge* > less_fit_edges = less_fit->edges;
    
    sort(more_fit_edges.begin(), more_fit_edges.end(), sort_RNN_Edges_by_innovation());
    sort(less_fit_edges.begin(), less_fit_edges.end(), sort_RNN_Edges_by_innovation());
    
    Log::debug("\tmore_fit innovation numbers AFTER SORT:\n");
    for (int32_t i = 0; i < (int32_t)more_fit_edges.size(); i++) {
        Log::trace("\t\t%d\n", more_fit_edges[i]->innovation_number);
    }
    Log::debug("\tless_fit innovation numbers AFTER SORT:\n");
    for (int32_t i = 0; i < (int32_t)less_fit_edges.size(); i++) {
        Log::debug("\t\t%d\n", less_fit_edges[i]->innovation_number);
    }
    
    vector< RNN_Recurrent_Edge* > more_fit_recurrent_edges = more_fit->recurrent_edges;
    vector< RNN_Recurrent_Edge* > less_fit_recurrent_edges = less_fit->recurrent_edges;
    
    sort(more_fit_recurrent_edges.begin(), more_fit_recurrent_edges.end(), sort_RNN_Recurrent_Edges_by_innovation());
    sort(less_fit_recurrent_edges.begin(), less_fit_recurrent_edges.end(), sort_RNN_Recurrent_Edges_by_innovation());
    
    int32_t more_fit_position = 0;
    int32_t less_fit_position = 0;
    
    while (more_fit_position < (int32_t)more_fit_edges.size() && less_fit_position < (int32_t)less_fit_edges.size()) {
        RNN_Edge* more_fit_edge = more_fit_edges[more_fit_position];
        RNN_Edge* less_fit_edge = less_fit_edges[less_fit_position];
    
        int more_fit_innovation = more_fit_edge->innovation_number;
        int less_fit_innovation = less_fit_edge->innovation_number;
    
        if (more_fit_innovation == less_fit_innovation) {
            attempt_edge_insert(child_edges, child_nodes, more_fit_edge, less_fit_edge, true);
    
            more_fit_position++;
            less_fit_position++;
        } else if (more_fit_innovation < less_fit_innovation) {
            bool set_enabled = rng_0_1(generator) < more_fit_crossover_rate;
            if (more_fit_edge->is_reachable()) set_enabled = true;
            else set_enabled = false;
    
            attempt_edge_insert(child_edges, child_nodes, more_fit_edge, NULL, set_enabled);
    
            more_fit_position++;
        } else {
            bool set_enabled = rng_0_1(generator) < less_fit_crossover_rate;
            if (less_fit_edge->is_reachable()) set_enabled = true;
            else set_enabled = false;
    
            attempt_edge_insert(child_edges, child_nodes, less_fit_edge, NULL, set_enabled);
    
            less_fit_position++;
        }
    }
    
    while (more_fit_position < (int32_t)more_fit_edges.size()) {
        RNN_Edge* more_fit_edge = more_fit_edges[more_fit_position];
    
        bool set_enabled = rng_0_1(generator) < more_fit_crossover_rate;
        if (more_fit_edge->is_reachable()) set_enabled = true;
        else set_enabled = false;
    
        attempt_edge_insert(child_edges, child_nodes, more_fit_edge, NULL, set_enabled);
    
        more_fit_position++;
    }
    
    while (less_fit_position < (int32_t)less_fit_edges.size()) {
        RNN_Edge* less_fit_edge = less_fit_edges[less_fit_position];
    
        bool set_enabled = rng_0_1(generator) < less_fit_crossover_rate;
        if (less_fit_edge->is_reachable()) set_enabled = true;
        else set_enabled = false;
    
        attempt_edge_insert(child_edges, child_nodes, less_fit_edge, NULL, set_enabled);
    
        less_fit_position++;
    }
    
    //do the same for recurrent_edges
    more_fit_position = 0;
    less_fit_position = 0;
    
    while (more_fit_position < (int32_t)more_fit_recurrent_edges.size() && less_fit_position < (int32_t)less_fit_recurrent_edges.size()) {
        RNN_Recurrent_Edge* more_fit_recurrent_edge = more_fit_recurrent_edges[more_fit_position];
        RNN_Recurrent_Edge* less_fit_recurrent_edge = less_fit_recurrent_edges[less_fit_position];
    
        int more_fit_innovation = more_fit_recurrent_edge->innovation_number;
        int less_fit_innovation = less_fit_recurrent_edge->innovation_number;
    
        if (more_fit_innovation == less_fit_innovation) {
            //do weight crossover
            attempt_recurrent_edge_insert(child_recurrent_edges, child_nodes, more_fit_recurrent_edge, less_fit_recurrent_edge, true);
    
            more_fit_position++;
            less_fit_position++;
        } else if (more_fit_innovation < less_fit_innovation) {
            bool set_enabled = rng_0_1(generator) < more_fit_crossover_rate;
            if (more_fit_recurrent_edge->is_reachable()) set_enabled = true;
            else set_enabled = false;
    
            attempt_recurrent_edge_insert(child_recurrent_edges, child_nodes, more_fit_recurrent_edge, NULL, set_enabled);
    
            more_fit_position++;
        } else {
            bool set_enabled = rng_0_1(generator) < less_fit_crossover_rate;
            if (less_fit_recurrent_edge->is_reachable()) set_enabled = true;
            else set_enabled = false;
    
            attempt_recurrent_edge_insert(child_recurrent_edges, child_nodes, less_fit_recurrent_edge, NULL, set_enabled);
    
            less_fit_position++;
        }
    }
    
    while (more_fit_position < (int32_t)more_fit_recurrent_edges.size()) {
        RNN_Recurrent_Edge* more_fit_recurrent_edge = more_fit_recurrent_edges[more_fit_position];
    
        bool set_enabled = rng_0_1(generator) < more_fit_crossover_rate;
        if (more_fit_recurrent_edge->is_reachable()) set_enabled = true;
        else set_enabled = false;
    
        attempt_recurrent_edge_insert(child_recurrent_edges, child_nodes, more_fit_recurrent_edge, NULL, set_enabled);
    
        more_fit_position++;
    }
    
    while (less_fit_position < (int32_t)less_fit_recurrent_edges.size()) {
        RNN_Recurrent_Edge* less_fit_recurrent_edge = less_fit_recurrent_edges[less_fit_position];
    
        bool set_enabled = rng_0_1(generator) < less_fit_crossover_rate;
        if (less_fit_recurrent_edge->is_reachable()) set_enabled = true;
        else set_enabled = false;
    
        attempt_recurrent_edge_insert(child_recurrent_edges, child_nodes, less_fit_recurrent_edge, NULL, set_enabled);
    
        less_fit_position++;
    }
    
    sort(child_nodes.begin(), child_nodes.end(), sort_RNN_Nodes_by_depth());
    sort(child_edges.begin(), child_edges.end(), sort_RNN_Edges_by_depth());
    sort(child_recurrent_edges.begin(), child_recurrent_edges.end(), sort_RNN_Recurrent_Edges_by_depth());
    
    RNN_Genome *child = new RNN_Genome(child_nodes, child_edges, child_recurrent_edges, weight_initialize, weight_inheritance, mutated_component_weight);
    child->set_parameter_names(input_parameter_names, output_parameter_names);
    child->set_normalize_bounds(normalize_type, normalize_mins, normalize_maxs, normalize_avgs, normalize_std_devs);
    
    
    if (more_fit->get_group_id() == less_fit->get_group_id()) {
        child->set_generated_by("crossover");
    } else {
        child->set_generated_by("island_crossover");
    }
    
    double mu, sigma;
    
    vector<double> new_parameters;
    
    // if weight_inheritance is same, all the weights of the child genome would be initialized as weight_initialize method
    if (weight_inheritance == weight_initialize) {
        Log::debug("weight inheritance at crossover method is %s, setting weights to %s randomly \n", WEIGHT_TYPES_STRING[weight_inheritance].c_str(), WEIGHT_TYPES_STRING[weight_inheritance].c_str());
        child->initialize_randomly();
    }
    
    child->get_weights(new_parameters);
    Log::debug("getting mu/sigma before assign reachability\n");
    child->get_mu_sigma(new_parameters, mu, sigma);
    
    child->assign_reachability();
    
    //reset the genomes statistics (as these carry over on copy)
    child->best_validation_mse = EXAMM_MAX_DOUBLE;
    child->best_validation_mae = EXAMM_MAX_DOUBLE;
    
    //get the new set of parameters (as new paramters may have been
    //added duriung mutatino) and set them to the initial parameters
    //for epigenetic_initialization
    child->get_weights(new_parameters);
    child->initial_parameters = new_parameters;
    
    Log::debug("checking parameters after crossover\n");
    child->get_mu_sigma(child->initial_parameters, mu, sigma);
    
    child->best_parameters.clear();
    
    return child;

}
